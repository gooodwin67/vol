#!/usr/bin/env node

import fs from 'node:fs';
import { createServer } from 'node:https';
import path from 'node:path';

import { blue, green, red, underline } from 'colorette';
import express from 'express';
import proxy from 'express-http-proxy';
import { parse } from 'node-html-parser';
import { open } from 'openurl';

import * as ssl from './cert';

const yargs = require('yargs');

const argv = yargs(process.argv.slice(2))
    .usage('Yandex.Games SDK developing server')
    .conflicts('host', 'path')
    .options({
        host: {
            description: 'Host where your game is available',
            alias: 'h',
            type: 'string',
        },
        path: {
            description: 'The folder where your game is located',
            alias: 'p',
            type: 'string',
        },
        'app-id': {
            description: 'ID of your game',
            alias: 'i',
            type: 'string',
        },
        csp: {
            description: 'Include CSP header',
            alias: 'c',
            type: 'boolean',
        },
        port: {
            description: 'Port to use',
            type: 'number',
        },
        log: {
            description: 'Enable request logger',
            default: true,
            alias: 'l',
            type: 'boolean',
        },
        tld: {
            description: 'TLD of yandex domain',
            default: 'ru',
            type: 'string',
        },
    })
    .check((argv: { host?: string; path?: string }) => {
        if (!(argv.host || argv.path)) {
            throw new Error('Error: one of path or host options required');
        }

        return true;
    }).argv;

const PORT = argv.port || 8080;
const S3_URL = 'http://games.s3.yandex.net';
const CSP_TIMEOUT = 60_000;
const DEF_APP_ID = 96458; // 1212
let csp = '';
let lastCspUpdate = 0;

const app = express();

if (argv.csp) {
    app.use(async (_req, _res, next) => {
        await fetchCSP();

        next();
    });
}

if (argv.log) {
    app.use((req, _res, next) => {
        console.info(blue(req.method), green(new Date().toISOString()), req.originalUrl);

        next();
    });
}

app.get(
    '/sdk.js',
    proxy(S3_URL, {
        proxyReqPathResolver: (_req) => {
            return '/sdk.js';
        },
    }),
);

app.get(
    /\/sdk\/_\/v2\.[0-9a-f]*\.js/,
    proxy(S3_URL, {
        proxyReqPathResolver: (req) => {
            return req.originalUrl;
        },
    }),
);

if (argv.path) {
    if (argv.csp) {
        app.get('/', (_req, res, _next) => {
            fs.readFile(path.join(argv.path, 'index.html'), function (err, data) {
                if (err) {
                    res.sendStatus(404);
                } else {
                    res.send(appendCspMeta(data.toString()));
                }
            });
        });
    }

    app.use(express.static(argv.path));
} else if (argv.host) {
    app.use(
        proxy(argv.host, {
            proxyReqOptDecorator: (proxyReqOpts, srcReq) => {
                if (!csp) {
                    return proxyReqOpts;
                }

                if (!proxyReqOpts.headers) {
                    proxyReqOpts.headers = {};
                }

                if (srcReq.path === '/' || srcReq.path === '/index.html') {
                    proxyReqOpts.headers['Accept-Encoding'] = 'identity';
                }

                return proxyReqOpts;
            },
            userResDecorator: (_proxyRes, proxyResData, userReq, _userRes) => {
                if (csp && (userReq.path === '/' || userReq.path === '/index.html')) {
                    return appendCspMeta(proxyResData);
                }

                return proxyResData;
            },
        }),
    );
}

const server = createServer(
    {
        key: ssl.key,
        cert: ssl.cert,
    },
    app,
);

server.listen(PORT, () => {
    console.info('Server is running on', underline(blue(`https://localhost:${PORT}/`)));

    const url = `https://yandex.${argv.tld || 'ru'}/games/app/${
        argv['app-id'] || red('<YOUR_APP_ID>')
    }/?draft=true&game_url=https://localhost:${PORT}`;

    console.info('You can open your game with', underline(blue(url)));

    if (argv['app-id']) {
        open(url);
    }
});

async function fetchCSP() {
    if (Date.now() < lastCspUpdate) {
        return;
    }

    lastCspUpdate = Date.now() + CSP_TIMEOUT;

    try {
        const appUrl = `https://yandex.${argv.tld || 'ru'}/games/app/${
            argv['app-id'] ? `${argv['app-id']}?draft=true` : DEF_APP_ID
        }`;

        const res = await fetch(appUrl);
        const appHtml = await res.text();
        const appRoot = parse(appHtml);
        const gameUrl = appRoot.getElementById('game-frame')?.getAttribute('src');

        if (!gameUrl) {
            return;
        }

        const gameRes = await fetch(gameUrl);
        const gameHtml = await gameRes.text();
        const gameDom = parse(gameHtml);
        const meta = gameDom.querySelector('meta[http-equiv=Content-Security-Policy]');

        const newCSP = meta?.getAttribute('content');

        if (newCSP) {
            csp = newCSP;
        }
    } catch (error) {
        console.error('Error while fetching csp rules', error);
    }
}

function appendCspMeta(html: string) {
    try {
        const dom = parse(html);
        const meta = `<meta http-equiv="Content-Security-Policy" content="${csp}">`;
        const head = dom.querySelector('head');

        head?.appendChild(parse(meta));

        return dom.toString();
    } catch (error) {
        console.error('Error while adding csp meta tag');

        return html;
    }
}
